# [프로그래머스] 숫자의 표현

> ### 문제 설명

Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다.

- 1 + 2 + 3 + 4 + 5 = 15
- 4 + 5 + 6 = 15
- 7 + 8 = 15
- 15 = 15

자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요.

##### 제한사항

- n은 10,000 이하의 자연수 입니다.

------

##### 입출력 예

| n    | result |
| ---- | ------ |
| 15   | 4      |

##### 입출력 예 설명

입출력 예#1
문제의 예시와 같습니다.

> ### 제출 답안

- 먼저 n을 2로 나눈다.
  - 어차피 2로 나누어서 그 몫이랑 그 다음 값의 합은 n을 넘기니 그 값까지만 조사하면 된다.
- 나눈 몫에서 2를 더해 리스트를 만든다.
- 리스트를 for loop를 돌린다.
  - 해당 자연수의 인덱스를 기점으로 다시 list에서 값을 가져와서 더한다.
  - 더한 값이 n과 같으면 answer에 1을 더한다.
  - n보다 크면 2번째 for loop를 탈출한다.
  - 작으면 계속 더한다.
- 마지막에 answer를 출력한다.

```python
def solution(n):
    num_list = [i for i in range(1, round(n / 2) + 2)]
    answer = 1
    for idx, value in enumerate(num_list):
        target = value
        for num in  num_list[idx +1:]:
            target += num
            if target == n:
                answer += 1
                break
            elif n < target:
                break
    return answer
```

| 테스트 1 〉  | 통과 (0.01ms, 10.4MB) |
| ------------ | --------------------- |
| 테스트 2 〉  | 통과 (0.24ms, 10.3MB) |
| 테스트 3 〉  | 통과 (0.29ms, 10.3MB) |
| 테스트 4 〉  | 통과 (0.18ms, 10.2MB) |
| 테스트 5 〉  | 통과 (0.05ms, 10.2MB) |
| 테스트 6 〉  | 통과 (0.01ms, 10.2MB) |
| 테스트 7 〉  | 통과 (0.15ms, 10.2MB) |
| 테스트 8 〉  | 통과 (0.09ms, 10.3MB) |
| 테스트 9 〉  | 통과 (0.02ms, 10.3MB) |
| 테스트 10 〉 | 통과 (0.34ms, 10.2MB) |
| 테스트 11 〉 | 통과 (0.35ms, 10.2MB) |
| 테스트 12 〉 | 통과 (0.19ms, 10.4MB) |
| 테스트 13 〉 | 통과 (0.22ms, 10.3MB) |
| 테스트 14 〉 | 통과 (0.16ms, 10.3MB) |
| 테스트 15 〉 | 통과 (0.01ms, 10.2MB) |
| 테스트 16 〉 | 통과 (0.01ms, 10.3MB) |
| 테스트 17 〉 | 통과 (0.02ms, 10.3MB) |
| 테스트 18 〉 | 통과 (0.01ms, 10.2MB) |

| 테스트 1 〉 | 통과 (20.73ms, 10.2MB) |
| ----------- | ---------------------- |
| 테스트 2 〉 | 통과 (8.19ms, 10.4MB)  |
| 테스트 3 〉 | 통과 (11.71ms, 10.4MB) |
| 테스트 4 〉 | 통과 (10.70ms, 10.3MB) |
| 테스트 5 〉 | 통과 (12.87ms, 10.4MB) |
| 테스트 6 〉 | 통과 (14.20ms, 10.4MB) |

> ### 수정 답안

- 나중에 보니 굳이 리스트로 만들지 않고 while문으로 1씩 더해주면 돼서 다시 작성해보았다.
- 지금 값에서 1씩 더해서 다시 target에 더하고 그 값이 n이랑 일치하는지만 확인하면 된다.
- 시간도 줄었고, 효율성 면에서 훨씬 좋아졌다.

```python
def solution(n):
    answer = 1
    for value in range(1, round(n / 2) + 1):
        target = value
        while target <= n:
            value += 1
            target += value
            if target == n:
                answer += 1
    return answer
```

| 테스트 1 〉  | 통과 (0.01ms, 10.2MB) |
| ------------ | --------------------- |
| 테스트 2 〉  | 통과 (0.15ms, 10.2MB) |
| 테스트 3 〉  | 통과 (0.11ms, 10.1MB) |
| 테스트 4 〉  | 통과 (0.11ms, 10.2MB) |
| 테스트 5 〉  | 통과 (0.04ms, 10.2MB) |
| 테스트 6 〉  | 통과 (0.01ms, 10.1MB) |
| 테스트 7 〉  | 통과 (0.10ms, 10.2MB) |
| 테스트 8 〉  | 통과 (0.14ms, 10.1MB) |
| 테스트 9 〉  | 통과 (0.01ms, 10.2MB) |
| 테스트 10 〉 | 통과 (0.20ms, 10.2MB) |
| 테스트 11 〉 | 통과 (0.21ms, 10.1MB) |
| 테스트 12 〉 | 통과 (0.12ms, 10.2MB) |
| 테스트 13 〉 | 통과 (0.13ms, 10.2MB) |
| 테스트 14 〉 | 통과 (0.10ms, 10.2MB) |
| 테스트 15 〉 | 통과 (0.00ms, 10.2MB) |
| 테스트 16 〉 | 통과 (0.00ms, 10.2MB) |
| 테스트 17 〉 | 통과 (0.01ms, 10.2MB) |
| 테스트 18 〉 | 통과 (0.01ms, 10.1MB) |

| 테스트 1 〉 | 통과 (3.38ms, 10.1MB) |
| ----------- | --------------------- |
| 테스트 2 〉 | 통과 (2.13ms, 10.1MB) |
| 테스트 3 〉 | 통과 (2.21ms, 10.2MB) |
| 테스트 4 〉 | 통과 (2.56ms, 10.1MB) |
| 테스트 5 〉 | 통과 (2.51ms, 10.3MB) |
| 테스트 6 〉 | 통과 (2.63ms, 10.2MB) |