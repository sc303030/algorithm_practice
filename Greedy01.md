### 큰 수의 법칙

배열 : `2,4,5,4,6` 

횟수 : 8번

최대 더 할수 있는 횟수 : 3번

배열의 크기 : 5

결과 : 6+6+6+5+6+6+6+5 = 46

---

배열 : `3,4,3,4,3` 

횟수 : 7번

최대 더 할수 있는 횟수 : 2번

배열의 크기 : 5

결과 : 4+4+4+4+4+4+4 = 28

---

**입력조건**

- 첫째 줄에 N(2 <= N <= 1,000), M(1 <= M <= 10,000), K(1<= K <= 10,000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
- 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1이상 10,000 이하의 수로 주어진다.
- 입력으로 주어지는 K는 항상 M보다 작거나 같다.

**출력조건**

- 첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.

**입력예시**

```
5 8 3
2 4 5 4 6
```

**출력 예시**

```
46
```

---

**내가 작성한 코드**

```python
import numpy as np
li = [2,4,5,4,6]
li.sort(reverse=True)
array1 = np.array(li)
sum = 0
N = 5
M = 8
K = 3
count = K
for i in range(M):
  if count > 0 :
    sum += array1[0]
    count -= 1
  elif count == 0:
    sum += array1[1]
    count = K
print(sum)
```

1. 배열이라고 해서 배열로 만들었다.
2. 사용자의 값을 입력 받은게 아니라 내가 먼저 코드에 값을 주었다.
3. 숫자를 큰 순서대로 정렬해서 맨 처음 값과 두 번째 값만 사용하기로 하였다.
4. N, M, K에 예시에 있는 값을 부여하였다.
5. 그 다음에 count에 K를 복사하였다.
6. M만큼 더하는 for 루프를 작성하였다.
7. count가 0보다 크면 계속 배열의 첫 번째 값을 더한다. 그 다음에 count를 1씩 뺀다.
8. 만약에 count가 0이면 두 번째 값을 더한다. 그 다음에 다시 count를 K로 지정한다.
9. 이 과정이 끝나고 sum을 출력한다. 

값은 정확하게 나왔지만 어설프다. 

---

**좋은 답안 01**

```python
n, m, k = map(int, input().split())
data = list(map(int, input().split()))

data.sort()
first = data[n - 1]
second = data[n - 2]

result = 0

while True:
  for i in range(k):
    if m == 0:
      break
    result += first
    m -= 1
  if m == 0:
    break
  result += second
  m -= 1

print(result)
```

1. input으로 숫자를 입력받아서 그 값을 n, m, k에 숫자로 저장한다.
2. data도 마찬가지로 입력받아서 저장한다.
3. data를 오름차순으로 정렬한다.
4. 배열의 길이 -1 을 하면 가장 큰 값의 인덱스랑 일치한다. 
5. 배열의 길이 -2 을 하면 가장 두 번째 큰 값의 인덱스랑 일치한다. 
6. 최대 더할 수 있는 횟수만큼 for루프를 돌린다. 
   1. 횟수가 0이되면 while을 빠져나간다.
   2. 0이 아니라면 k만큼 result에 최댓값을 더한다.
7. k만큼 더했으면 그 다음에 두 번째 큰 값을 더한다. 
8. 그 다음에 다시 또 최댓값을 더한다.
9. m을 계속 1식 빼면서 m이 0이되면 while을 빠져나간다.

m의 크기가 100억이 넘어가면 조건인 1초를 넘어버린다. 그러면 어떻게 해야 할까?

6+6+6+5 / 6+6+6+5 를 보면 반복되는 수열임을 알 수 있다.  수열의 길이가 (1 + k) 임을 알 수 있다. 

m을 (1 + k) 로 나누면 수열의 반복되는 횟수가 나온다. 여기에 k를 곱하면 가장 큰 수가 등장하는 횟수가 된다. 

딱 나눠 떨어지지 않는 경우에는 m * (1 + K) 의 나머지만큼 최댓값을 더해준다. 

**식이 만들어 진다**

```
int(m / (1 + k)) * k + m % (1 + k)
```

 **좋은 답안 02**

```python
n, m, k = map(int, input().split())
data = list(map(int, input().split()))

data.sort()
first = data[n - 1]
second = data[n - 2]

count = int( m / (k + 1)) * k
count += m % (k + 1)

result = 0
result += (count) * first
result += (m - count) * second

print(result)
```

1. count에 나누어 떨어지는 경우를 저장한다.
2. 그 다음에 나머지 만큼 최댓값을 더해주는 경우를 저장한다.
3. result에 최댓값을 먼저 곱해서 저장한다.
4. 그 다음에 최댓값을 더하고 남은 횟수에 두 번째로 큰 값을 곱해서 저장한다. 

